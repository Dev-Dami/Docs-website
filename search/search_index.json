{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"DYMS <p>Dynamic Yet Minimal System - A modern programming language with hybrid execution that's fast, expressive, and developer-friendly.</p> Get Started in 2 Minutes Explore Features Try DYMS Right Now <pre><code>// Your first DYMS program\nlet message = \"Hello, World!\"\nprintln(message)\n</code></pre>      go run . hello.dy    Hybrid Execution <p>       Smart routing between a high-performance VM and flexible interpreter. Get the speed of compiled languages with the flexibility of scripting.     </p> Zero Configuration <p>       No complex build systems or package managers. Just write <code>.dy</code> files and run them with <code>go run .</code>. Perfect for rapid prototyping and scripting.     </p> Developer Experience <p>       Intuitive syntax, excellent error messages, and a REPL for interactive development. Code feels natural and debugging is actually pleasant.     </p> Modern Features <p>       Closures, first-class functions, module system, and comprehensive standard library. Everything you need without the bloat.     </p> Lightweight <p>       Minimal dependencies, fast startup time, and efficient memory usage. Perfect for CLI tools, automation scripts, and embedded scenarios.     </p> Extensible <p>       Built-in module system with <code>time</code> and <code>fmaths</code> libraries. Easy to extend with custom modules for your specific needs.     </p>"},{"location":"#why-choose-dyms","title":"Why Choose DYMS?","text":"<p>For Script Writers: Replace complex bash scripts with readable, maintainable DYMS code that handles errors gracefully.</p> <p>For Prototypers: Skip the ceremony of larger languages. Go from idea to working code in minutes.</p> <p>For Educators: Teach programming concepts without fighting language complexity. Focus on logic, not syntax.</p> <p>For System Admins: Automate tasks with a language that's more powerful than bash but simpler than Python.</p>"},{"location":"#next-steps","title":"Next Steps","text":"Quick Start <p>Install and run your first DYMS program in under 2 minutes.</p> Language Tour <p>Explore DYMS syntax, features, and programming patterns.</p> Examples <p>See real-world DYMS programs and learn by example.</p> How It Works <p>Deep dive into DYMS architecture and implementation.</p>"},{"location":"about/","title":"About DYMS","text":"<p>DYMS (Dynamic Yet Minimal System Interpreter) is a lightweight, embeddable scripting language interpreter built in Go. It\u2019s designed to balance simplicity, performance, and extensibility, making it ideal for embedding in applications, rapid prototyping, or exploring language/runtime design.</p>"},{"location":"about/#why-dyms","title":"Why DYMS?","text":"<p>DYMS was created with the goal of providing:</p> <ul> <li>A minimal yet expressive syntax for scripting</li> <li>A hybrid runtime that intelligently chooses between interpretation and bytecode VM execution</li> <li>High performance loops and operations with optimized opcodes</li> <li>Easy extensibility with modules and user-defined functions</li> <li>Robust error handling with clear, line-aware reporting</li> </ul> <p>It takes inspiration from lightweight languages like Lua and Wren, while borrowing ideas from Crafting Interpreters, SICP, and the Dragon Book.</p>"},{"location":"about/#key-highlights","title":"Key Highlights","text":"<ul> <li>Simple Core Language: Variables, functions, arrays, maps, loops, conditionals</li> <li>Execution Engine: Hybrid interpreter + high-performance VM</li> <li>Standard Modules: Time and advanced math (<code>fmaths</code>)</li> <li>Pretty Printing: Inline and multi-line formats with sorted output</li> <li>Safe &amp; Friendly: Exception handling (<code>try/catch</code>), strict <code>const</code>, and clear error messages</li> </ul>"},{"location":"about/#status","title":"Status","text":"<ul> <li>Current Version: Demo 0.5</li> <li>License: MIT</li> <li>Requirements: Go \u2265 1.24</li> <li>Project is under active development, with focus on:</li> <li>Improving performance and optimizations</li> <li>Expanding the standard library</li> <li>Adding more language features (switch, regex, file I/O)</li> </ul>"},{"location":"about/#inspiration-philosophy","title":"Inspiration &amp; Philosophy","text":"<p>DYMS embraces the principle of being dynamic yet minimal:</p> <ul> <li>Dynamic enough to handle real scripting needs (closures, maps, math, modules)</li> <li>Minimal enough to remain small, understandable, and easy to embed</li> </ul> <p>It aims to provide a practical scripting layer while staying approachable for developers who want to study, extend, or customize an interpreter.</p> <p>\u00a9 2025 DYMS. Licensed under the MIT License.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#execution-pipeline","title":"Execution Pipeline","text":"<ol> <li>Lexer \u2192 Tokens: <code>lexer/lexer.go</code></li> <li>Parser \u2192 AST: <code>parser/parser.go</code></li> <li>Hybrid Runtime System: <code>runtime/hybrid.go</code></li> <li>Smart routing between VM and interpreter based on code complexity</li> <li>AST \u2192 Compiler \u2192 Bytecode \u2192 VM (optimized performance)</li> <li>AST \u2192 Interpreter (flexible evaluation)</li> <li>Performance tracking and adaptive execution</li> </ol>"},{"location":"architecture/#core-components","title":"Core Components","text":"<ul> <li>AST System: Node definitions, pretty printing, function and import support</li> <li>VM &amp; Compiler: High-performance stack-based VM with 20+ fast opcodes, peephole optimization, constant deduplication, call frame management</li> <li>Runtime Environment: Lexical scoping, dynamic value system, interpreter, pretty printing</li> <li>Error System: Line/column-aware parser and runtime errors</li> <li>Module System: Built-in libraries with aliasing support</li> </ul>"},{"location":"cli_usage/","title":"Command-Line Usage","text":"<p><code>dyms &lt;filename&gt;</code></p> <p>Examples:</p> <pre><code># Run directly with Go\ngo run . test/01_basic_features.dy\n\n# Build and run\n.\\build.bat build\n.\\build\\dyms.exe test/21_simple_test.dy\n\n# Run all tests\n.\\build.bat test\n</code></pre>"},{"location":"contributing/","title":"Contributing to DYMS","text":"<p>DYMS is an open source project that welcomes contributions from developers of all skill levels.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24 or higher</li> <li>Git for version control</li> <li>Basic familiarity with interpreters/compilers</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/Dev-Dami/DYMS-Lang\ncd DYMS-Lang\n\n# Test the interpreter\ngo run . test/01_basic_features.dy\n\n# Run the REPL\ngo run .\n</code></pre>"},{"location":"contributing/#areas-for-contribution","title":"Areas for Contribution","text":""},{"location":"contributing/#language-features","title":"Language Features","text":"<ul> <li>Standard library expansion</li> <li>Error message improvements  </li> <li>Performance optimizations</li> <li>New control flow constructs</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Code examples and tutorials</li> <li>Architecture explanations</li> <li>API reference improvements</li> <li>Translation to other languages</li> </ul>"},{"location":"contributing/#tooling","title":"Tooling","text":"<ul> <li>Editor plugins (VS Code, Vim, etc.)</li> <li>Debugger integration</li> <li>Build tools and package managers</li> <li>Testing frameworks</li> </ul>"},{"location":"contributing/#infrastructure","title":"Infrastructure","text":"<ul> <li>CI/CD improvements</li> <li>Benchmarking suite</li> <li>Website enhancements</li> <li>Release automation</li> </ul>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>Follow these guidelines when contributing:</p>"},{"location":"contributing/#go-code","title":"Go Code","text":"<ul> <li>Use <code>gofmt</code> for formatting</li> <li>Follow Go naming conventions</li> <li>Add comments for public functions</li> <li>Include tests for new features</li> </ul>"},{"location":"contributing/#dyms-code","title":"DYMS Code","text":"<ul> <li>Use <code>let</code> by default, <code>var</code> when mutation needed</li> <li>Prefer descriptive function names</li> <li>Keep functions focused and small</li> <li>Add comments for complex logic</li> </ul>"},{"location":"contributing/#documentation_1","title":"Documentation","text":"<ul> <li>Use clear, concise language</li> <li>Provide runnable code examples</li> <li>Test all code snippets</li> <li>Follow existing formatting patterns</li> </ul>"},{"location":"contributing/#submitting-changes","title":"Submitting Changes","text":""},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch: <code>git checkout -b feature/new-feature</code></li> <li>Make your changes with clear commits</li> <li>Test thoroughly with existing test suite</li> <li>Submit a pull request with detailed description</li> </ol>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>Use clear, descriptive commit messages:</p> GOOD:  - `Add support for hexadecimal number literals` - `Fix memory leak in closure evaluation` - `Improve error messages for undefined variables`  AVOID:  - `Fix bug` - `Update code` - `Changes`"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run language tests\ngo run . test/\n\n# Run specific test file  \ngo run . test/05_functions.dy\n\n# Test REPL functionality\ngo run .\n</code></pre>"},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<p>Create test files in the <code>test/</code> directory:</p> <pre><code>// test/new_feature.dy\n// Test description: Array destructuring\n\nlet arr = [1, 2, 3]\nlet [a, b, c] = arr\n\nprintln(\"a:\", a)  // Should print 1\nprintln(\"b:\", b)  // Should print 2\nprintln(\"c:\", c)  // Should print 3\n</code></pre>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":""},{"location":"contributing/#bug-reports","title":"Bug Reports","text":"<p>Include the following information:</p> <ul> <li>DYMS version and platform</li> <li>Minimal code example that reproduces the issue</li> <li>Expected vs actual behavior</li> <li>Error messages or stack traces</li> </ul>"},{"location":"contributing/#feature-requests","title":"Feature Requests","text":"<p>Describe:</p> <ul> <li>The problem you're trying to solve</li> <li>Proposed solution or API design</li> <li>Use cases and examples</li> <li>Impact on existing code</li> </ul>"},{"location":"contributing/#development-guidelines","title":"Development Guidelines","text":""},{"location":"contributing/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Profile before optimizing</li> <li>Prefer VM-optimized code paths for hot loops  </li> <li>Minimize allocations in critical paths</li> <li>Cache frequently accessed values</li> </ul>"},{"location":"contributing/#memory-management","title":"Memory Management","text":"<ul> <li>Clear large data structures when done</li> <li>Avoid circular references</li> <li>Use local variables when possible</li> <li>Consider object pooling for high-frequency allocations</li> </ul>"},{"location":"contributing/#error-handling","title":"Error Handling","text":"<ul> <li>Provide specific, actionable error messages</li> <li>Include context about what the user was trying to do</li> <li>Suggest corrections when possible</li> <li>Handle edge cases gracefully</li> </ul>"},{"location":"contributing/#community","title":"Community","text":""},{"location":"contributing/#communication-channels","title":"Communication Channels","text":"<ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>GitHub Discussions: General questions and community chat</li> <li>Pull Requests: Code reviews and collaboration</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive</li> <li>Focus on constructive feedback</li> <li>Help newcomers learn and contribute</li> <li>Maintain professional communication</li> </ul>"},{"location":"contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>Repository README</li> <li>Release notes</li> <li>Documentation credits</li> <li>Project website</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Check existing issues and discussions</li> <li>Read the architecture documentation</li> <li>Look at recent pull requests for examples</li> <li>Ask questions in GitHub Discussions</li> </ul> <p>Thank you for contributing to DYMS!</p>"},{"location":"demos/","title":"Demos","text":"<p>All test files are organized in the <code>test/</code> directory for easy access:</p> <ul> <li>Basic Features: <code>go run . test/01_basic_features.dy</code></li> <li>Type System: <code>go run . test/02_types_demo.dy</code></li> <li>Performance Tests: <code>go run . test/03_performance_basic.dy</code></li> <li>VM Optimizations: <code>go run . test/04_vm_optimization_benchmark.dy</code></li> <li>Bytecode Speed: <code>go run . test/05_fast_bytecode_test.dy</code></li> <li>Time Module: <code>go run . test/06_time_module.dy</code></li> <li>Time &amp; Math Demo: <code>go run . test/07_time_math_demo.dy</code></li> <li>Algorithm Patterns: <code>go run . test/08_algorithm_patterns.dy</code></li> <li>Map Operations: <code>go run . test/09_map_operations.dy</code></li> <li>Basic Math: <code>go run . test/10_math_basic.dy</code></li> <li>Math Optimization: <code>go run . test/11_math_optimization.dy</code></li> <li>Comprehensive Math Benchmark: <code>go run . test/12_math_comprehensive_benchmark.dy</code></li> <li>New Language Features: <code>go run . test/21_simple_test.dy</code></li> </ul>"},{"location":"features/","title":"Features","text":""},{"location":"features/#variables","title":"Variables","text":"<ul> <li><code>let</code> \u2014 immutable by default</li> <li><code>var</code> \u2014 mutable</li> <li><code>const</code> \u2014 immutable with strict enforcement</li> </ul>"},{"location":"features/#data-types","title":"Data Types","text":"<ul> <li>Number (float64), String, Boolean, Array (heterogeneous), Map (string keys)</li> </ul>"},{"location":"features/#functions","title":"Functions","text":"<ul> <li>User-defined: <code>funct name(params) { body }</code></li> <li>Supports closures and lexical environment capture</li> <li><code>return value</code></li> <li>Automatic null-padding for missing arguments</li> </ul>"},{"location":"features/#module-system","title":"Module System","text":"<ul> <li><code>import \"module\" as alias</code></li> <li>Built-in <code>time</code> library: <code>now()</code>, <code>millis()</code>, <code>sleep()</code></li> <li>Built-in <code>fmaths</code> library: advanced math functions</li> </ul>"},{"location":"features/#operators","title":"Operators","text":"<ul> <li>Arithmetic: <code>+ - * / %</code></li> <li>Comparison: <code>== != &lt; &lt;= &gt; &gt;=</code></li> <li>Logical: <code>&amp;&amp; ||</code></li> <li>Increment/Decrement: <code>++var, var++, --var, var--</code></li> <li>String concatenation with automatic type conversion</li> </ul>"},{"location":"features/#control-flow","title":"Control Flow","text":"<ul> <li>Conditional: <code>if/else</code></li> <li>Loops: <code>while</code> and <code>for range(i, N)</code> with <code>break</code> and <code>continue</code></li> <li>Exception handling: <code>try/catch</code></li> </ul>"},{"location":"features/#advanced-features","title":"Advanced Features","text":"<ul> <li>Hybrid execution engine: Smart routing between VM and interpreter</li> <li>High-performance bytecode VM: 20+ optimized opcodes</li> <li>Compiler optimizations: peephole, constant folding, dead code elimination</li> <li>Ultra-fast loops, memory optimization</li> <li>Property access via dot notation for maps</li> <li>String escaping: <code>\\n, \\t, \\r\\n, \\\\, \\\"</code></li> <li>Single-line comments: <code>//</code></li> </ul>"},{"location":"further_reading/","title":"Further Reading &amp; Inspiration","text":"<ul> <li>Books: Crafting Interpreters, Dragon Book, PLAI</li> <li>Languages: Lua, Wren, Go</li> <li>Other: SICP, Awesome Compilers</li> </ul>"},{"location":"language_overview/","title":"Language Overview","text":""},{"location":"language_overview/#core-syntax","title":"Core Syntax","text":"<pre><code>let x = 10\nvar y = 20\nconst who = \"DYMS\"\nlet ok = true\n\nif (x &gt; 5) { println(\"x &gt; 5\") } else { println(\"x &lt;= 5\") }\nfor range(i, 10) {\n    if (i == 5) { break }\n    if (i % 2 == 0) { continue }\n    println(i)\n}\nwhile (y &gt; 0) { --y }\n</code></pre>"},{"location":"language_overview/#variables","title":"Variables","text":"<p>DYMS has three keywords for declaring variables:</p> <ul> <li><code>let</code>: Declares a variable that cannot be reassigned. This is the most common way to declare variables.</li> <li><code>var</code>: Declares a mutable variable that can be reassigned.</li> <li><code>const</code>: Declares a constant variable that cannot be reassigned and must be initialized with a constant value.</li> </ul>"},{"location":"language_overview/#data-structures","title":"Data Structures","text":""},{"location":"language_overview/#arrays","title":"Arrays","text":"<p>Arrays are ordered collections of values. They can hold values of different types.</p> <pre><code>let arr = [1, \"two\", true, [4, 5]]\nprintln(arr)\n</code></pre>"},{"location":"language_overview/#maps","title":"Maps","text":"<p>Maps are collections of key-value pairs. The keys must be strings.</p> <pre><code>let m = {\"name\": \"DYMS\", \"version\": 0.5, \"stable\": true}\nprintln(m.name) // Access properties using dot notation\n</code></pre>"},{"location":"language_overview/#functions-and-closures","title":"Functions and Closures","text":"<p>Functions are first-class citizens in DYMS. They can be assigned to variables, passed as arguments, and returned from other functions.</p> <pre><code>funct greet(name) {\n    return \"Hello, \" + name + \"!\"\n}\n\nlet message = greet(\"World\")\nprintln(message)\n</code></pre> <p>DYMS also supports closures, which are functions that capture their surrounding environment.</p> <pre><code>funct makeCounter() {\n    let count = 0\n    funct increment() {\n        ++count\n        return count\n    }\n    return increment\n}\n\nlet counter1 = makeCounter()\nprintln(counter1()) // 1\nprintln(counter1()) // 2\n\nlet counter2 = makeCounter()\nprintln(counter2()) // 1\n</code></pre>"},{"location":"language_overview/#error-handling","title":"Error Handling","text":"<p>DYMS supports <code>try/catch</code> blocks for handling errors.</p> <pre><code>funct safeDivide(a, b) {\n    try {\n        if (b == 0) {\n            return \"Division by zero\"\n        }\n        return a / b\n    } catch(e) {\n        println(\"An error occurred:\", e)\n        return null\n    }\n}\n\nprintln(safeDivide(10, 2))\nprintln(safeDivide(10, 0))\n</code></pre>"},{"location":"language_overview/#module-system","title":"Module System","text":"<pre><code>import \"time\" as t\nimport \"fmaths\" as math\n\nlet t0 = t.now()\nlet start = t.millis()\n\nfor range(i, 1000000) {}\n\nlet t1 = t.now()\nprintln(\"Elapsed: \" + (t1 - t0) + \" seconds\")\nt.sleep(1.5)\n</code></pre>"},{"location":"language_overview/#math-library","title":"Math Library","text":"<pre><code>import \"fmaths\" as math\n\n// Mathematical constants\nprintln(\"\u03c0 = \" + math.pi())\nprintln(\"e = \" + math.e())\n\n// Basic functions\nprintln(\"sqrt(16) = \" + math.sqrt(16))     // 4\nprintln(\"pow(2, 8) = \" + math.pow(2, 8))  // 256\n</code></pre>"},{"location":"patterns/","title":"Code Patterns &amp; Best Practices","text":"<p>This guide covers common patterns, idioms, and best practices when writing DYMS code. These patterns will help you write more maintainable, efficient, and idiomatic DYMS programs.</p>"},{"location":"patterns/#variable-declarations","title":"Variable Declarations","text":""},{"location":"patterns/#prefer-let-over-var","title":"Prefer <code>let</code> over <code>var</code>","text":"<p>Use <code>let</code> by default unless you specifically need reassignment:</p> <pre><code>// Good - immutable by default\nlet name = \"Alice\"\nlet users = [\"Alice\", \"Bob\", \"Charlie\"]\nlet config = {\"debug\": true, \"port\": 8080}\n\n// Good - explicit mutability when needed\nvar counter = 0\nvar isRunning = true\n\n// Avoid - unnecessary mutability\nvar userName = \"Alice\"  // This never changes\n</code></pre>"},{"location":"patterns/#use-const-for-true-constants","title":"Use <code>const</code> for True Constants","text":"<p>Reserve <code>const</code> for compile-time constants that will never change:</p> <pre><code>// Good - mathematical constants\nconst PI = 3.14159265359\nconst E = 2.71828182846\nconst MAX_RETRIES = 3\n\n// Good - configuration that's truly constant\nconst API_VERSION = \"v1\"\nconst DEFAULT_TIMEOUT = 30\n\n// Avoid - runtime values\nconst currentTime = time.now()  // This changes each run\n</code></pre>"},{"location":"patterns/#function-patterns","title":"Function Patterns","text":""},{"location":"patterns/#factory-functions-for-object-creation","title":"Factory Functions for Object Creation","text":"<p>Use factory functions to create objects with methods:</p> <pre><code>funct createUser(name, email) {\n    let userData = {\n        \"name\": name,\n        \"email\": email,\n        \"created\": time.now()\n    }\n\n    return {\n        \"getName\": funct() { return userData.name },\n        \"getEmail\": funct() { return userData.email },\n        \"getAge\": funct() { return time.now() - userData.created },\n        \"updateEmail\": funct(newEmail) {\n            userData.email = newEmail\n            return userData.email\n        }\n    }\n}\n\n// Usage\nlet user = createUser(\"Alice\", \"alice@example.com\")\nprintln(user.getName())\nuser.updateEmail(\"alice.new@example.com\")\n</code></pre>"},{"location":"patterns/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Leverage first-class functions for powerful abstractions:</p> <pre><code>// Generic retry logic\nfunct withRetry(operation, maxRetries) {\n    return funct() {\n        let attempts = 0\n        while (attempts &lt; maxRetries) {\n            try {\n                return operation()\n            } catch(error) {\n                ++attempts\n                if (attempts &gt;= maxRetries) {\n                    return \"Failed after \" + maxRetries + \" attempts\"\n                }\n                println(\"Attempt\", attempts, \"failed, retrying...\")\n            }\n        }\n    }\n}\n\n// Usage\nlet unreliableTask = funct() {\n    if (time.now() % 3 == 0) {  // Randomly fail\n        return \"Task failed\"\n    }\n    return \"Task succeeded\"\n}\n\nlet robustTask = withRetry(unreliableTask, 3)\nprintln(robustTask())\n</code></pre>"},{"location":"patterns/#partial-application-pattern","title":"Partial Application Pattern","text":"<p>Create specialized functions from general ones:</p> <pre><code>funct makeValidator(rule, message) {\n    return funct(value) {\n        if (rule(value)) {\n            return {\"valid\": true, \"value\": value}\n        }\n        return {\"valid\": false, \"error\": message}\n    }\n}\n\n// Create specific validators\nlet isEmail = makeValidator(\n    funct(str) { return str.indexOf(\"@\") &gt; 0 },\n    \"Invalid email format\"\n)\n\nlet isPositive = makeValidator(\n    funct(num) { return num &gt; 0 },\n    \"Must be positive number\"\n)\n\n// Usage\nprintln(isEmail(\"alice@example.com\"))  // Valid\nprintln(isPositive(-5))                 // Invalid\n</code></pre>"},{"location":"patterns/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"patterns/#result-pattern","title":"Result Pattern","text":"<p>Instead of throwing exceptions, return result objects:</p> <pre><code>funct safeParse(str) {\n    try {\n        let num = parseFloat(str)  // Hypothetical function\n        return {\"success\": true, \"value\": num}\n    } catch(error) {\n        return {\"success\": false, \"error\": error}\n    }\n}\n\nfunct processNumber(str) {\n    let result = safeParse(str)\n    if (result.success) {\n        return result.value * 2\n    }\n    return \"Error: \" + result.error\n}\n\nprintln(processNumber(\"42\"))    // 84\nprintln(processNumber(\"abc\"))   // Error: ...\n</code></pre>"},{"location":"patterns/#chain-of-responsibility","title":"Chain of Responsibility","text":"<p>Handle different error types gracefully:</p> <pre><code>funct createErrorHandler() {\n    let handlers = []\n\n    return {\n        \"register\": funct(condition, handler) {\n            handlers[handlers.length] = {\"condition\": condition, \"handler\": handler}\n        },\n\n        \"handle\": funct(error) {\n            for range(i, handlers.length) {\n                let h = handlers[i]\n                if (h.condition(error)) {\n                    return h.handler(error)\n                }\n            }\n            return \"Unhandled error: \" + error\n        }\n    }\n}\n\nlet errorHandler = createErrorHandler()\nerrorHandler.register(\n    funct(e) { return e.indexOf(\"network\") &gt;= 0 },\n    funct(e) { return \"Network issue - please check connection\" }\n)\nerrorHandler.register(\n    funct(e) { return e.indexOf(\"timeout\") &gt;= 0 },\n    funct(e) { return \"Request timed out - please try again\" }\n)\n\nprintln(errorHandler.handle(\"network connection failed\"))\n</code></pre>"},{"location":"patterns/#data-structure-patterns","title":"Data Structure Patterns","text":""},{"location":"patterns/#builder-pattern-for-complex-objects","title":"Builder Pattern for Complex Objects","text":"<p>Build complex objects step by step:</p> <pre><code>funct createQueryBuilder() {\n    let query = {\n        \"table\": \"\",\n        \"fields\": [],\n        \"conditions\": [],\n        \"limit\": 0\n    }\n\n    return {\n        \"from\": funct(tableName) {\n            query.table = tableName\n            return this  // Enable chaining\n        },\n\n        \"select\": funct(fields) {\n            query.fields = fields\n            return this\n        },\n\n        \"where\": funct(condition) {\n            query.conditions[query.conditions.length] = condition\n            return this\n        },\n\n        \"limitTo\": funct(count) {\n            query.limit = count\n            return this\n        },\n\n        \"build\": funct() {\n            let sql = \"SELECT \" + query.fields.join(\", \")\n            sql = sql + \" FROM \" + query.table\n            if (query.conditions.length &gt; 0) {\n                sql = sql + \" WHERE \" + query.conditions.join(\" AND \")\n            }\n            if (query.limit &gt; 0) {\n                sql = sql + \" LIMIT \" + query.limit\n            }\n            return sql\n        }\n    }\n}\n\n// Usage\nlet sql = createQueryBuilder()\n    .from(\"users\")\n    .select([\"name\", \"email\"])\n    .where(\"age &gt; 18\")\n    .where(\"active = true\")\n    .limitTo(10)\n    .build()\n\nprintln(sql)\n</code></pre>"},{"location":"patterns/#array-processing-patterns","title":"Array Processing Patterns","text":"<p>Work with arrays efficiently:</p> <pre><code>// Map-like function\nfunct mapArray(array, transform) {\n    let result = []\n    for range(i, array.length) {\n        result[i] = transform(array[i])\n    }\n    return result\n}\n\n// Filter-like function\nfunct filterArray(array, predicate) {\n    let result = []\n    let resultIndex = 0\n    for range(i, array.length) {\n        if (predicate(array[i])) {\n            result[resultIndex] = array[i]\n            ++resultIndex\n        }\n    }\n    return result\n}\n\n// Usage\nlet numbers = [1, 2, 3, 4, 5]\nlet doubled = mapArray(numbers, funct(n) { return n * 2 })\nlet evens = filterArray(numbers, funct(n) { return n % 2 == 0 })\n\nprintln(\"Doubled:\", doubled)  // [2, 4, 6, 8, 10]\nprintln(\"Evens:\", evens)      // [2, 4]\n</code></pre>"},{"location":"patterns/#module-patterns","title":"Module Patterns","text":""},{"location":"patterns/#namespace-pattern","title":"Namespace Pattern","text":"<p>Organize related functions in objects:</p> <pre><code>// Create a math utilities namespace\nlet MathUtils = {\n    \"clamp\": funct(value, min, max) {\n        if (value &lt; min) return min\n        if (value &gt; max) return max\n        return value\n    },\n\n    \"lerp\": funct(start, end, factor) {\n        return start + (end - start) * factor\n    },\n\n    \"distance\": funct(x1, y1, x2, y2) {\n        let dx = x2 - x1\n        let dy = y2 - y1\n        return math.sqrt(dx * dx + dy * dy)\n    }\n}\n\n// Usage\nprintln(\"Clamped:\", MathUtils.clamp(15, 0, 10))  // 10\nprintln(\"Lerp:\", MathUtils.lerp(0, 100, 0.5))    // 50\n</code></pre>"},{"location":"patterns/#module-initialization-pattern","title":"Module Initialization Pattern","text":"<p>Set up modules with configuration:</p> <pre><code>funct createLogger(config) {\n    let settings = {\n        \"level\": config.level || \"INFO\",\n        \"prefix\": config.prefix || \"[LOG]\",\n        \"timestamp\": config.timestamp || true\n    }\n\n    return {\n        \"info\": funct(message) {\n            if (settings.level == \"DEBUG\" || settings.level == \"INFO\") {\n                let output = settings.prefix + \" \"\n                if (settings.timestamp) {\n                    output = output + \"[\" + time.now() + \"] \"\n                }\n                println(output + message)\n            }\n        },\n\n        \"debug\": funct(message) {\n            if (settings.level == \"DEBUG\") {\n                println(\"[DEBUG] \" + message)\n            }\n        },\n\n        \"configure\": funct(newConfig) {\n            // Update settings\n            if (newConfig.level) settings.level = newConfig.level\n            if (newConfig.prefix) settings.prefix = newConfig.prefix\n        }\n    }\n}\n\nlet logger = createLogger({\"level\": \"DEBUG\", \"prefix\": \"[APP]\"})\nlogger.info(\"Application started\")\nlogger.debug(\"Debug information\")\n</code></pre>"},{"location":"patterns/#performance-patterns","title":"Performance Patterns","text":""},{"location":"patterns/#memoization","title":"Memoization","text":"<p>Cache expensive function results:</p> <pre><code>funct memoize(fn) {\n    let cache = {}\n\n    return funct(arg) {\n        let key = \"\" + arg  // Convert to string key\n        if (cache[key] != null) {\n            return cache[key]\n        }\n\n        let result = fn(arg)\n        cache[key] = result\n        return result\n    }\n}\n\n// Expensive function (fibonacci)\nlet fibonacci = memoize(funct(n) {\n    if (n &lt;= 1) return n\n    // This would be slow without memoization\n    return fibonacci(n - 1) + fibonacci(n - 2)\n})\n\nprintln(\"Fib(10):\", fibonacci(10))  // Fast after first call\n</code></pre>"},{"location":"patterns/#lazy-evaluation","title":"Lazy Evaluation","text":"<p>Defer expensive computations:</p> <pre><code>funct createLazy(factory) {\n    let cached = null\n    let computed = false\n\n    return {\n        \"get\": funct() {\n            if (!computed) {\n                cached = factory()\n                computed = true\n            }\n            return cached\n        },\n\n        \"reset\": funct() {\n            cached = null\n            computed = false\n        }\n    }\n}\n\nlet expensiveData = createLazy(funct() {\n    println(\"Computing expensive data...\")\n    // Simulate expensive computation\n    let result = []\n    for range(i, 1000) {\n        result[i] = math.sqrt(i)\n    }\n    return result\n})\n\n// Only computed when needed\nprintln(\"First access:\", expensiveData.get().length)  // Computes here\nprintln(\"Second access:\", expensiveData.get().length) // Uses cache\n</code></pre>"},{"location":"patterns/#testing-patterns","title":"Testing Patterns","text":""},{"location":"patterns/#simple-assertion-framework","title":"Simple Assertion Framework","text":"<p>Build a basic testing framework:</p> <pre><code>funct createTester(suiteName) {\n    let tests = []\n    let passed = 0\n    let failed = 0\n\n    return {\n        \"test\": funct(name, testFn) {\n            tests[tests.length] = {\"name\": name, \"fn\": testFn}\n        },\n\n        \"run\": funct() {\n            println(\"Running test suite:\", suiteName)\n            println(\"=\" * 40)\n\n            for range(i, tests.length) {\n                let test = tests[i]\n                try {\n                    test.fn()\n                    println(\"\u2713 \" + test.name)\n                    ++passed\n                } catch(error) {\n                    println(\"\u2717 \" + test.name + \" - \" + error)\n                    ++failed\n                }\n            }\n\n            println(\"\\nResults:\", passed, \"passed,\", failed, \"failed\")\n        }\n    }\n}\n\nlet suite = createTester(\"Math Functions\")\n\nsuite.test(\"Addition works\", funct() {\n    if (2 + 2 != 4) {\n        return \"Expected 4, got \" + (2 + 2)\n    }\n})\n\nsuite.test(\"Division by zero\", funct() {\n    if (10 / 0 == 0) {\n        return \"Division by zero should not equal 0\"\n    }\n})\n\nsuite.run()\n</code></pre>"},{"location":"patterns/#style-guidelines","title":"Style Guidelines","text":""},{"location":"patterns/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Functions: Use camelCase: <code>getUserData()</code>, <code>calculateTotal()</code></li> <li>Variables: Use camelCase: <code>userName</code>, <code>totalCount</code></li> <li>Constants: Use UPPER_CASE: <code>MAX_RETRIES</code>, <code>API_KEY</code></li> <li>Factory functions: Prefix with \"create\": <code>createUser()</code>, <code>createLogger()</code></li> </ul>"},{"location":"patterns/#code-organization","title":"Code Organization","text":"<ul> <li>Group related functions together</li> <li>Use consistent indentation (2 or 4 spaces)</li> <li>Add comments for complex logic</li> <li>Keep functions focused on a single responsibility</li> <li>Prefer composition over complex inheritance patterns</li> </ul>"},{"location":"patterns/#error-messages","title":"Error Messages","text":"<p>Write helpful error messages:</p> <pre><code>// Good - specific and actionable\nif (age &lt; 0) {\n    return \"Age must be a positive number, got: \" + age\n}\n\n// Avoid - vague and unhelpful  \nif (age &lt; 0) {\n    return \"Invalid age\"\n}\n</code></pre> <p>These patterns will help you write more maintainable and idiomatic DYMS code. Remember, the best pattern is often the simplest one that solves your problem clearly and correctly!</p>"},{"location":"performance/","title":"Performance Guide","text":"<p>DYMS is designed to be fast out of the box with its hybrid execution engine, but understanding how it works can help you write even more efficient code. This guide covers performance characteristics, optimization techniques, and best practices.</p>"},{"location":"performance/#hybrid-execution-engine","title":"Hybrid Execution Engine","text":"<p>DYMS automatically chooses between two execution paths based on your code:</p>"},{"location":"performance/#vm-path-high-performance","title":"VM Path (High Performance)","text":"<ul> <li>When: Complex computations, loops, mathematical operations</li> <li>How: Code is compiled to bytecode and executed on a stack-based VM</li> <li>Benefits: ~10x faster than interpreter for compute-heavy code</li> </ul> <pre><code>// This automatically uses the VM path\nimport \"fmaths\" as math\n\nfunct calculatePi(iterations) {\n    var pi = 0.0\n    for range(i, iterations) {\n        let term = math.pow(-1, i) / (2 * i + 1)\n        pi = pi + term\n    }\n    return pi * 4\n}\n\nlet result = calculatePi(100000)  // VM handles this efficiently\nprintln(\"\u03c0 approximation:\", result)\n</code></pre>"},{"location":"performance/#interpreter-path-high-flexibility","title":"Interpreter Path (High Flexibility)","text":"<ul> <li>When: Dynamic operations, reflection, complex object manipulation</li> <li>How: Direct AST evaluation</li> <li>Benefits: More flexible, better for prototyping and dynamic code</li> </ul> <pre><code>// This uses the interpreter path\nfunct createDynamicObject(props) {\n    let obj = {}\n    for range(i, props.length) {\n        let prop = props[i]\n        obj[prop.name] = prop.value  // Dynamic property creation\n    }\n    return obj\n}\n\nlet user = createDynamicObject([\n    {\"name\": \"firstName\", \"value\": \"Alice\"},\n    {\"name\": \"lastName\", \"value\": \"Smith\"}\n])\n</code></pre>"},{"location":"performance/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"performance/#fast-operations","title":"Fast Operations","text":"<p>These operations are highly optimized:</p> <pre><code>import \"time\" as t\nimport \"fmaths\" as math\n\n// Arithmetic operations\nlet start = t.millis()\nvar sum = 0\nfor range(i, 1000000) {\n    sum = sum + i * 2 - 1  // Fast arithmetic\n}\nprintln(\"Arithmetic:\", t.millis() - start, \"ms\")\n\n// Mathematical functions\nstart = t.millis()\nfor range(i, 100000) {\n    let result = math.sqrt(i) + math.sin(i)  // Optimized math\n}\nprintln(\"Math functions:\", t.millis() - start, \"ms\")\n\n// Array access with numeric indices\nlet arr = [1, 2, 3, 4, 5]\nstart = t.millis()\nfor range(i, 100000) {\n    let val = arr[i % arr.length]  // Fast array access\n}\nprintln(\"Array access:\", t.millis() - start, \"ms\")\n</code></pre>"},{"location":"performance/#slower-operations","title":"Slower Operations","text":"<p>These operations require more overhead:</p> <pre><code>import \"time\" as t\n\n// String concatenation in loops\nlet start = t.millis()\nvar result = \"\"\nfor range(i, 1000) {  // Note: smaller loop due to overhead\n    result = result + i  // Creates new string each time\n}\nprintln(\"String concat:\", t.millis() - start, \"ms\")\n\n// Dynamic property access\nlet obj = {\"a\": 1, \"b\": 2, \"c\": 3}\nstart = t.millis()\nfor range(i, 100000) {\n    let key = [\"a\", \"b\", \"c\"][i % 3]\n    let val = obj[key]  // Dynamic property lookup\n}\nprintln(\"Dynamic access:\", t.millis() - start, \"ms\")\n</code></pre>"},{"location":"performance/#optimization-techniques","title":"Optimization Techniques","text":""},{"location":"performance/#1-prefer-numeric-operations","title":"1. Prefer Numeric Operations","text":"<p>Mathematical operations are heavily optimized:</p> <pre><code>// FAST - numeric operations\nfunct fastDistance(x1, y1, x2, y2) {\n    let dx = x2 - x1\n    let dy = y2 - y1\n    return math.sqrt(dx * dx + dy * dy)\n}\n\n// SLOW - string operations\nfunct slowDistance(p1, p2) {\n    let coords1 = p1.split(\",\")  // String parsing\n    let coords2 = p2.split(\",\")\n    // ... more string processing\n}\n</code></pre>"},{"location":"performance/#2-use-arrays-for-sequential-data","title":"2. Use Arrays for Sequential Data","text":"<p>Arrays with numeric indices are faster than object property access:</p> <pre><code>// \u2705 Fast - array-based approach\nlet positions = [[0, 0], [1, 2], [3, 4]]\n\nfunct updatePositions(positions, deltaX, deltaY) {\n    for range(i, positions.length) {\n        positions[i][0] = positions[i][0] + deltaX  // Fast numeric access\n        positions[i][1] = positions[i][1] + deltaY\n    }\n}\n\n// \u274c Slower - object-based approach  \nlet entities = [\n    {\"x\": 0, \"y\": 0},\n    {\"x\": 1, \"y\": 2},\n    {\"x\": 3, \"y\": 4}\n]\n\nfunct updateEntities(entities, deltaX, deltaY) {\n    for range(i, entities.length) {\n        entities[i].x = entities[i].x + deltaX  // Property lookup overhead\n        entities[i].y = entities[i].y + deltaY\n    }\n}\n</code></pre>"},{"location":"performance/#3-minimize-string-operations-in-loops","title":"3. Minimize String Operations in Loops","text":"<p>Build strings efficiently:</p> <pre><code>// \u2705 Fast - build array first, then join\nfunct buildReport(data) {\n    let lines = []\n    for range(i, data.length) {\n        lines[i] = \"Item \" + i + \": \" + data[i]\n    }\n    return lines.join(\"\\\\n\")  // Single join operation\n}\n\n// \u274c Slow - concatenate in loop\nfunct slowBuildReport(data) {\n    var report = \"\"\n    for range(i, data.length) {\n        report = report + \"Item \" + i + \": \" + data[i] + \"\\\\n\"  // Creates new string each iteration\n    }\n    return report\n}\n</code></pre>"},{"location":"performance/#4-cache-function-results","title":"4. Cache Function Results","text":"<p>Avoid recalculating expensive operations:</p> <pre><code>// Memoization for expensive functions\nfunct memoize(fn) {\n    let cache = {}\n    return funct(arg) {\n        let key = \"\" + arg\n        if (cache[key] != null) {\n            return cache[key]\n        }\n        let result = fn(arg)\n        cache[key] = result\n        return result\n    }\n}\n\n// Expensive calculation\nlet expensiveFunction = memoize(funct(n) {\n    var result = 0\n    for range(i, n * 1000) {\n        result = result + math.sqrt(i)\n    }\n    return result\n})\n\n// First call is slow, subsequent calls are instant\nprintln(expensiveFunction(100))  // Calculated\nprintln(expensiveFunction(100))  // Cached\n</code></pre>"},{"location":"performance/#5-use-local-variables","title":"5. Use Local Variables","text":"<p>Access to local variables is faster than property access:</p> <pre><code>import \"fmaths\" as math\n\n// \u2705 Fast - cache frequently used values\nfunct optimizedCalculation(config, data) {\n    let threshold = config.threshold  // Cache property access\n    let multiplier = config.multiplier\n\n    var result = 0\n    for range(i, data.length) {\n        if (data[i] &gt; threshold) {  // Use cached value\n            result = result + data[i] * multiplier\n        }\n    }\n    return result\n}\n\n// \u274c Slower - repeated property access\nfunct unoptimizedCalculation(config, data) {\n    var result = 0\n    for range(i, data.length) {\n        if (data[i] &gt; config.threshold) {  // Property access each iteration\n            result = result + data[i] * config.multiplier\n        }\n    }\n    return result\n}\n</code></pre>"},{"location":"performance/#memory-optimization","title":"Memory Optimization","text":""},{"location":"performance/#avoid-memory-leaks","title":"Avoid Memory Leaks","text":"<p>DYMS has automatic garbage collection, but you can help:</p> <pre><code>// \u2705 Good - clean references when done\nfunct processLargeDataset(data) {\n    let processor = createProcessor()\n    let results = processor.process(data)\n\n    // Clear large objects when done\n    processor = null\n    data = null\n\n    return results\n}\n\n// \u2705 Good - use local scope\nfunct calculateStats(numbers) {\n    // These variables are automatically cleaned up\n    var sum = 0\n    var max = numbers[0]\n    var min = numbers[0]\n\n    for range(i, numbers.length) {\n        let num = numbers[i]\n        sum = sum + num\n        if (num &gt; max) max = num\n        if (num &lt; min) min = num\n    }\n\n    return {\"sum\": sum, \"avg\": sum / numbers.length, \"max\": max, \"min\": min}\n}\n</code></pre>"},{"location":"performance/#reuse-objects-when-possible","title":"Reuse Objects When Possible","text":"<pre><code>// \u2705 Efficient - reuse result objects\nlet resultPool = []\n\nfunct getResult() {\n    if (resultPool.length &gt; 0) {\n        return resultPool.pop()  // Reuse existing object\n    }\n    return {\"value\": 0, \"status\": \"ok\"}  // Create new if needed\n}\n\nfunct releaseResult(result) {\n    result.value = 0      // Reset state\n    result.status = \"ok\"\n    resultPool[resultPool.length] = result  // Return to pool\n}\n\n// Usage\nlet result = getResult()\nresult.value = 42\nresult.status = \"processed\"\n// ... use result ...\nreleaseResult(result)  // Return for reuse\n</code></pre>"},{"location":"performance/#benchmarking-your-code","title":"Benchmarking Your Code","text":"<p>Use the time module to measure performance:</p> <pre><code>import \"time\" as t\n\nfunct benchmark(name, fn, iterations) {\n    let start = t.millis()\n\n    for range(i, iterations) {\n        fn()\n    }\n\n    let elapsed = t.millis() - start\n    let perOp = elapsed / iterations\n\n    println(name + \":\")\n    println(\"  Total:\", elapsed, \"ms\")\n    println(\"  Per operation:\", perOp, \"ms\")\n    println(\"  Operations/sec:\", 1000 / perOp)\n    println()\n}\n\n// Compare different approaches\nlet data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nbenchmark(\"Array sum (for loop)\", funct() {\n    var sum = 0\n    for range(i, data.length) {\n        sum = sum + data[i]\n    }\n}, 10000)\n\nbenchmark(\"Array sum (while loop)\", funct() {\n    var sum = 0\n    var i = 0\n    while (i &lt; data.length) {\n        sum = sum + data[i]\n        ++i\n    }\n}, 10000)\n</code></pre>"},{"location":"performance/#performance-tips-summary","title":"Performance Tips Summary","text":"DO THIS  - Use numeric operations when possible - Cache frequently accessed properties - Prefer arrays for sequential data - Use local variables for loop calculations - Minimize string concatenation in loops - Take advantage of DYMS's automatic optimization  AVOID THIS  - Excessive string concatenation in loops - Repeated property lookups in tight loops - Creating many temporary objects - Deep nested object access - Complex string parsing in performance-critical code"},{"location":"performance/#profile-and-measure","title":"Profile and Measure","text":"<ul> <li>Use <code>time.millis()</code> to measure execution time</li> <li>Test with realistic data sizes</li> <li>Compare different approaches</li> <li>Focus optimization on the slowest parts</li> </ul> <p>Remember: Premature optimization is the root of all evil. Write clear, correct code first, then optimize the parts that actually matter for your application's performance!</p>"},{"location":"performance/#real-world-performance-example","title":"Real-World Performance Example","text":"<p>Here's a practical example showing DYMS performance in action:</p> <pre><code>import \"time\" as t\nimport \"fmaths\" as math\n\n// Simulate a particle physics calculation\nfunct simulateParticles(numParticles, steps) {\n    // Use arrays for better performance\n    let positions = []\n    let velocities = []\n\n    // Initialize particles\n    for range(i, numParticles) {\n        positions[i] = [math.random() * 100, math.random() * 100]\n        velocities[i] = [math.random() * 2 - 1, math.random() * 2 - 1]\n    }\n\n    let start = t.millis()\n\n    // Simulation loop - this will use VM optimization\n    for range(step, steps) {\n        for range(i, numParticles) {\n            // Update positions (fast numeric operations)\n            positions[i][0] = positions[i][0] + velocities[i][0]\n            positions[i][1] = positions[i][1] + velocities[i][1]\n\n            // Boundary checking\n            if (positions[i][0] &lt; 0 || positions[i][0] &gt; 100) {\n                velocities[i][0] = -velocities[i][0]\n            }\n            if (positions[i][1] &lt; 0 || positions[i][1] &gt; 100) {\n                velocities[i][1] = -velocities[i][1]\n            }\n        }\n    }\n\n    let elapsed = t.millis() - start\n    let particleUpdates = numParticles * steps\n\n    println(\"Simulated\", particleUpdates, \"particle updates in\", elapsed, \"ms\")\n    println(\"Performance:\", particleUpdates / elapsed * 1000, \"updates/second\")\n\n    return positions\n}\n\n// Run simulation\nsimulateParticles(1000, 100)  // 100,000 particle updates\n</code></pre> <p>This example demonstrates DYMS's performance strengths: the tight numeric loops will automatically be optimized by the VM, giving you excellent performance for computational tasks while maintaining the simplicity of scripting language syntax.</p>"},{"location":"pretty_printing/","title":"Pretty Printing","text":"<ul> <li><code>pretty(v)</code> \u2014 inline, single-line formatting</li> <li><code>prettyml(v)</code> \u2014 multi-line, indented, stable output with sorted keys</li> <li><code>printlnml(v)</code> \u2014 prints <code>prettyml</code> output with newline</li> </ul>"},{"location":"project_structure/","title":"Project Structure","text":"<ul> <li>Entry Point: <code>main.go</code></li> <li>Core: lexer, parser, AST</li> <li>Runtime: compiler, VM, interpreter, value system, environment, error handling, pretty printing</li> <li>Libraries: Built-in modules like <code>time</code></li> <li>Tests / Demos: Comprehensive <code>.dy</code> scripts demonstrating all features</li> </ul>"},{"location":"quick_start/","title":"Quick Start: Your First DYMS Script","text":"<p>Welcome to DYMS! This guide will walk you through writing and running your first script. We'll cover the basics of setting up your environment, writing a \"Hello, World!\" program, and running it using the DYMS interpreter.</p>"},{"location":"quick_start/#1-prerequisites","title":"1. Prerequisites","text":"<p>Before you begin, make sure you have Go (version 1.24 or higher) installed on your system. You can check your Go version by running:</p> <pre><code>go version\n</code></pre>"},{"location":"quick_start/#2-hello-world","title":"2. \"Hello, World!\"","text":"<p>Let's start with the classic \"Hello, World!\" program. Create a new file named <code>hello.dy</code> and add the following code:</p> <pre><code>// Your first DYMS script!\nprintln(\"Hello, World!\");\n</code></pre> <p>This script uses the built-in <code>println</code> function to print the string \"Hello, World!\" to the console.</p>"},{"location":"quick_start/#3-running-your-script","title":"3. Running Your Script","text":"<p>You can run your script directly using <code>go run</code>:</p> <pre><code>go run .\\main.go hello.dy\n</code></pre> <p>You should see the following output:</p> <pre><code>[println]: Hello, World!\n</code></pre>"},{"location":"quick_start/#4-using-the-repl-read-eval-print-loop","title":"4. Using the REPL (Read-Eval-Print Loop)","text":"<p>DYMS also comes with a REPL, which is a great way to experiment with the language. To start the REPL, run the interpreter without any arguments:</p> <pre><code>go run .\\main.go\n</code></pre> <p>You'll be greeted with the DYMS prompt. You can type in any valid DYMS code and see the result immediately:</p> <pre><code>DYMS &gt; let message = \"Hello from the REPL!\";\nDYMS &gt; println(message);\n[println]: Hello from the REPL!\n</code></pre>"},{"location":"quick_start/#5-whats-next","title":"5. What's Next?","text":"<p>Congratulations! You've written and executed your first DYMS script. You're now ready to explore the language further. Here are some suggestions for what to do next:</p> <ul> <li>Dive into the Language Overview to learn more about DYMS syntax and features.</li> <li>Check out the Demos to see more examples of what you can do with DYMS.</li> <li>Explore the Standard Library to discover the built-in functions and modules available to you.</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#completed-v04","title":"Completed (v0.4)","text":"<ul> <li>High-performance bytecode VM: 20+ specialized opcodes for common operations</li> <li>Compiler optimizations: Peephole optimization, constant deduplication, automatic optimization passes</li> <li>Fast execution paths: Optimized opcodes for constants (0, 1, true, false, null), loops, string operations</li> <li>Memory optimizations: Pre-allocated stacks, constant pooling, improved garbage collection</li> <li>User-defined functions with closures and return statements</li> <li>Enhanced time library with <code>now()</code>, <code>millis()</code>, <code>sleep()</code></li> <li>Property access via dot notation for maps</li> <li>Advanced pretty printing with stable output</li> <li>Comprehensive error handling with line/column tracking</li> </ul>"},{"location":"roadmap/#completed-v05","title":"Completed (v0.5)","text":"<ul> <li>Hybrid execution engine: Smart VM/interpreter routing with performance tracking</li> <li>Loop control flow: <code>break</code> and <code>continue</code> statements with proper scoping</li> <li>Increment/decrement operators: Pre/post <code>++</code> and <code>--</code> with identifier support</li> <li>Exception handling: <code>try/catch</code> blocks with error variable binding</li> <li>Performance optimizations: Ultra-fast loops with sub-150ms execution</li> <li>Memory improvements: Object pooling and variable reuse patterns</li> <li>Array and map bracket indexing</li> <li>Expanded standard library with advanced <code>fmaths</code> module</li> <li>Modulo operator (<code>%</code>) support</li> <li>Enhanced identifier support (underscores allowed)</li> <li>Function expressions: Anonymous functions and lambda support</li> <li>File extension change: Now uses <code>.dy</code> and <code>.dx</code> extensions</li> </ul>"},{"location":"roadmap/#future-enhancements","title":"Future Enhancements","text":"<ul> <li><code>switch/case</code> statements</li> <li>File I/O functions</li> <li>Regular expressions</li> <li>Debugging tools</li> <li>User-defined modules</li> <li>Advanced VM optimizations</li> </ul>"},{"location":"standard_library/","title":"Standard Library","text":"<p>DYMS comes with a set of built-in modules that provide additional functionality. You can import these modules into your scripts using the <code>import</code> keyword.</p>"},{"location":"standard_library/#time-module","title":"<code>time</code> Module","text":"<p>The <code>time</code> module provides functions for working with time.</p> <ul> <li><code>now()</code>: Returns the current time in seconds since the Unix epoch.</li> <li><code>millis()</code>: Returns the current time in milliseconds since the Unix epoch.</li> <li><code>sleep(seconds)</code>: Pauses the execution of the script for the specified number of seconds.</li> </ul>"},{"location":"standard_library/#fmaths-module","title":"<code>fmaths</code> Module","text":"<p>The <code>fmaths</code> module provides a collection of advanced mathematical functions.</p> <ul> <li><code>pi()</code>: Returns the value of Pi.</li> <li><code>e()</code>: Returns the value of Euler's number.</li> <li><code>sqrt(x)</code>: Returns the square root of <code>x</code>.</li> <li><code>pow(x, y)</code>: Returns <code>x</code> raised to the power of <code>y</code>.</li> <li><code>abs(x)</code>: Returns the absolute value of <code>x</code>.</li> <li><code>sin(x)</code>, <code>cos(x)</code>, <code>tan(x)</code>: Trigonometric functions.</li> <li><code>log(x)</code>, <code>log10(x)</code>, <code>log2(x)</code>: Logarithmic functions.</li> <li><code>exp(x)</code>: Returns <code>e</code> raised to the power of <code>x</code>.</li> <li><code>ceil(x)</code>, <code>floor(x)</code>, <code>round(x)</code>: Rounding functions.</li> <li><code>min(x, y)</code>, <code>max(x, y)</code>: Returns the minimum or maximum of two numbers.</li> </ul>"},{"location":"tutorial/","title":"Interactive DYMS Tutorial","text":"<p>Welcome to the hands-on DYMS tutorial! This guide will take you from zero to productive in about 15 minutes. Each step builds on the previous one, so we recommend following along in order.</p> <p>Follow Along</p> <p>Open your terminal and try each example as we go. The best way to learn DYMS is by writing DYMS code!</p>"},{"location":"tutorial/#step-1-your-first-program","title":"Step 1: Your First Program","text":"<p>Let's start with the classic \"Hello, World!\" program. Create a file called <code>hello.dy</code>:</p> <pre><code>// hello.dy - Your first DYMS program\nprintln(\"Hello, World!\")\n</code></pre>  go run . hello.dy  <p>Output: <pre><code>[println]: Hello, World!\n</code></pre></p> <p>Checkpoint</p> <p>SUCCESS: You've successfully run your first DYMS program!</p>"},{"location":"tutorial/#step-2-variables-and-data-types","title":"Step 2: Variables and Data Types","text":"<p>DYMS has three ways to declare variables. Let's explore them:</p> <pre><code>// variables.dy - Understanding DYMS variables\nlet name = \"Alice\"        // Immutable - cannot be reassigned\nvar age = 25             // Mutable - can be reassigned\nconst PI = 3.14159       // Constant - truly immutable\n\nprintln(\"Name:\", name)\nprintln(\"Age:\", age)\nprintln(\"Pi:\", PI)\n\n// This works - var can be reassigned\nage = 26\nprintln(\"New age:\", age)\n\n// This would cause an error:\n// name = \"Bob\"  // Error! let variables cannot be reassigned\n</code></pre> <p>Try it yourself: What happens if you uncomment the last line?</p> <p>Variable Types</p> <ul> <li><code>let</code>: Immutable reference (most common)</li> <li><code>var</code>: Mutable variable</li> <li><code>const</code>: Compile-time constant</li> </ul>"},{"location":"tutorial/#step-3-data-structures","title":"Step 3: Data Structures","text":"<p>DYMS supports arrays and maps (objects) with a clean syntax:</p> <pre><code>// data_structures.dy - Arrays and Maps\nlet numbers = [1, 2, 3, 4, 5]\nlet mixed = [1, \"hello\", true, [1, 2]]  // Arrays can hold any types\n\nlet person = {\n    \"name\": \"Bob\",\n    \"age\": 30,\n    \"active\": true\n}\n\nprintln(\"Numbers:\", numbers)\nprintln(\"Mixed array:\", mixed)\nprintln(\"Person:\", person)\n\n// Access map properties with dot notation\nprintln(\"Person's name:\", person.name)\nprintln(\"Person's age:\", person.age)\n</code></pre> <p>Flexible Types</p> <p>DYMS is dynamically typed - arrays and maps can contain any combination of types!</p>"},{"location":"tutorial/#step-4-control-flow","title":"Step 4: Control Flow","text":"<p>Let's add some logic to our programs:</p> <pre><code>// control_flow.dy - Conditions and loops\nlet temperature = 22\n\nif (temperature &gt; 25) {\n    println(\"It's hot!\")\n} else if (temperature &lt; 15) {\n    println(\"It's cold!\")\n} else {\n    println(\"Perfect weather!\")\n}\n\n// For loops with range\nprintln(\"Counting to 5:\")\nfor range(i, 5) {\n    println(\"Count:\", i)\n}\n\n// While loops\nlet countdown = 3\nwhile (countdown &gt; 0) {\n    println(\"Countdown:\", countdown)\n    --countdown\n}\nprintln(\"Blast off!\")\n</code></pre> <p>Loop Control</p> <p>Use <code>break</code> to exit loops early and <code>continue</code> to skip to the next iteration.</p>"},{"location":"tutorial/#step-5-functions-and-closures","title":"Step 5: Functions and Closures","text":"<p>Functions are first-class citizens in DYMS:</p> <pre><code>// functions.dy - Function definition and usage\nfunct greet(name) {\n    return \"Hello, \" + name + \"!\"\n}\n\nfunct add(a, b) {\n    return a + b\n}\n\nprintln(greet(\"World\"))\nprintln(\"2 + 3 =\", add(2, 3))\n\n// Closures - functions that capture their environment\nfunct makeMultiplier(factor) {\n    return funct(number) {\n        return number * factor\n    }\n}\n\nlet double = makeMultiplier(2)\nlet triple = makeMultiplier(3)\n\nprintln(\"Double 5:\", double(5))  // 10\nprintln(\"Triple 4:\", triple(4))  // 12\n</code></pre> <p>Closures</p> <p>Closures are powerful - they remember the environment where they were created!</p>"},{"location":"tutorial/#step-6-working-with-modules","title":"Step 6: Working with Modules","text":"<p>DYMS comes with useful built-in modules:</p> <pre><code>// modules.dy - Using built-in modules\nimport \"time\" as t\nimport \"fmaths\" as math\n\n// Time operations\nlet start = t.now()\nprintln(\"Current time:\", start)\n\n// Math operations\nprintln(\"\u03c0 =\", math.pi())\nprintln(\"e =\", math.e())\nprintln(\"\u221a16 =\", math.sqrt(16))\nprintln(\"2^8 =\", math.pow(2, 8))\nprintln(\"sin(\u03c0/2) =\", math.sin(math.pi() / 2))\n\n// Performance timing\nfor range(i, 1000000) {\n    // Simulate some work\n    let dummy = math.sqrt(i)\n}\n\nlet end = t.now()\nprintln(\"Operation took\", end - start, \"seconds\")\n\n// Sleep for demonstration\nprintln(\"Sleeping for 1 second...\")\nt.sleep(1)\nprintln(\"Done!\")\n</code></pre> <p>Available Modules</p> <ul> <li><code>time</code>: Time operations, sleeping, performance measurement</li> <li><code>fmaths</code>: Advanced mathematical functions and constants</li> </ul>"},{"location":"tutorial/#step-7-error-handling","title":"Step 7: Error Handling","text":"<p>Handle errors gracefully with try/catch:</p> <pre><code>// error_handling.dy - Graceful error handling\nfunct safeDivide(a, b) {\n    try {\n        if (b == 0) {\n            return \"Cannot divide by zero\"\n        }\n        return a / b\n    } catch(error) {\n        println(\"An error occurred:\", error)\n        return null\n    }\n}\n\nprintln(\"10 \u00f7 2 =\", safeDivide(10, 2))\nprintln(\"10 \u00f7 0 =\", safeDivide(10, 0))\n\n// Another example with potential errors\nfunct processArray(arr) {\n    try {\n        let result = 0\n        for range(i, 5) {\n            result = result + arr[i]  // Might go out of bounds\n        }\n        return result\n    } catch(error) {\n        return \"Array processing failed: \" + error\n    }\n}\n\nlet shortArray = [1, 2, 3]\nprintln(\"Processing result:\", processArray(shortArray))\n</code></pre>"},{"location":"tutorial/#step-8-putting-it-all-together","title":"Step 8: Putting It All Together","text":"<p>Let's create a more substantial program that combines everything we've learned:</p> <pre><code>// calculator.dy - A simple calculator program\nimport \"fmaths\" as math\n\nfunct createCalculator() {\n    let history = []\n\n    return {\n        \"add\": funct(a, b) {\n            let result = a + b\n            history[history.length] = \"Added \" + a + \" + \" + b + \" = \" + result\n            return result\n        },\n\n        \"multiply\": funct(a, b) {\n            let result = a * b  \n            history[history.length] = \"Multiplied \" + a + \" \u00d7 \" + b + \" = \" + result\n            return result\n        },\n\n        \"power\": funct(base, exp) {\n            let result = math.pow(base, exp)\n            history[history.length] = \"Calculated \" + base + \"^\" + exp + \" = \" + result\n            return result\n        },\n\n        \"getHistory\": funct() {\n            return history\n        }\n    }\n}\n\n// Use the calculator\nlet calc = createCalculator()\n\nprintln(\"Calculator Demo:\")\nprintln(\"5 + 3 =\", calc.add(5, 3))\nprintln(\"4 \u00d7 7 =\", calc.multiply(4, 7))  \nprintln(\"2^8 =\", calc.power(2, 8))\n\nprintln(\"\\nCalculation History:\")\nlet history = calc.getHistory()\nfor range(i, history.length) {\n    println(\"-\", history[i])\n}\n</code></pre> <p>Congratulations!</p> <p>COMPLETED: You've finished the DYMS tutorial! You now know:</p> <ul> <li>Variable declarations (<code>let</code>, <code>var</code>, <code>const</code>)</li> <li>Data structures (arrays, maps)</li> <li>Control flow (if/else, loops)</li> <li>Functions and closures</li> <li>Module system</li> <li>Error handling</li> <li>Complex program organization</li> </ul>"},{"location":"tutorial/#next-steps","title":"Next Steps","text":"<p>Now that you've mastered the basics, here's where to go next:</p>"},{"location":"tutorial/#explore-more-examples","title":"Explore More Examples","text":"<p>Check out the Demos page for real-world DYMS programs and patterns.</p>"},{"location":"tutorial/#deep-dive-into-language-features","title":"Deep Dive into Language Features","text":"<p>Read the complete Language Overview for advanced topics.</p>"},{"location":"tutorial/#understand-the-architecture","title":"Understand the Architecture","text":"<p>Learn how DYMS works under the hood in the Architecture section.</p>"},{"location":"tutorial/#build-something-cool","title":"Build Something Cool","text":"<p>Start your own DYMS project! Some ideas: - A CLI tool for file processing - An automation script for repetitive tasks - A text-based game - A data analysis script</p>"},{"location":"tutorial/#get-help","title":"Get Help","text":"<ul> <li>Check the Standard Library reference</li> <li>Browse the Project Structure guide</li> <li>Explore the Command-Line Usage options</li> </ul>"},{"location":"tutorial/#practice-exercises","title":"Practice Exercises","text":"<p>Ready to test your skills? Try these challenges:</p> <p>Beginner Challenge</p> <p>Write a program that calculates compound interest given principal, rate, and time.</p> <p>Intermediate Challenge</p> <p>Create a word counter that reads text and reports the most frequent words.</p> <p>Advanced Challenge</p> <p>Build a simple task scheduler that can add, list, and remove tasks with due dates.</p> <p>Happy coding with DYMS!</p>"},{"location":"blog/v0_5_release/","title":"New in DYMS v0.5: Hybrid Execution, Exception Handling, and More!","text":"<p>We're excited to announce the release of DYMS v0.5! This release brings a host of new features and improvements that make the language more powerful, performant, and robust.</p>"},{"location":"blog/v0_5_release/#hybrid-execution-engine","title":"Hybrid Execution Engine","text":"<p>The most significant new feature in v0.5 is the introduction of a hybrid execution engine. This engine intelligently routes code between a high-performance bytecode VM and a flexible interpreter. This means that your scripts will run faster than ever before, while still maintaining the flexibility of an interpreted language.</p>"},{"location":"blog/v0_5_release/#exception-handling","title":"Exception Handling","text":"<p>DYMS now supports <code>try/catch</code> blocks for exception handling. This allows you to write more robust code that can gracefully handle errors and unexpected situations.</p>"},{"location":"blog/v0_5_release/#other-new-features","title":"Other New Features","text":"<p>In addition to the hybrid execution engine and exception handling, v0.5 also includes the following new features:</p> <ul> <li>Loop control flow: <code>break</code> and <code>continue</code> statements are now supported in loops.</li> <li>Increment/decrement operators: You can now use <code>++</code> and <code>--</code> to increment and decrement variables.</li> <li>Expanded standard library: The <code>fmaths</code> module has been expanded with new functions.</li> </ul> <p>We're really excited about this release, and we can't wait to see what you build with it. As always, we welcome your feedback and contributions.</p>"}]}